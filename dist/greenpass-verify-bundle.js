/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
var GreenPassVerify;
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/greenpass-verify.js":
/*!*********************************!*\
  !*** ./src/greenpass-verify.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"onLoad\": () => (/* binding */ onLoad),\n/* harmony export */   \"onVerifySignature\": () => (/* binding */ onVerifySignature),\n/* harmony export */   \"onStartScanClick\": () => (/* binding */ onStartScanClick),\n/* harmony export */   \"onStopScanClick\": () => (/* binding */ onStopScanClick),\n/* harmony export */   \"onSelectCameraButtonClick\": () => (/* binding */ onSelectCameraButtonClick)\n/* harmony export */ });\n/*\n * Copyright 2021 Nimrod Zimerman\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n/*** SHA256 ***/\n\n// Perform SHA256 over a byte array.\n// Returns a byte array.\nasync function sha256DigestPromise(byteArr) {\n  const hash = await crypto.subtle.digest(\"sha-256\", byteArr);  // Returns promise of ArrayBuffer.\n  return new Uint8Array(hash);\n}\n\n\n/*** Conversion ***/\n\n// Convert a binary string to an ArrayBuffer.\nfunction binaryStrToArrayBuf(str) {\n  const arrBuf = new ArrayBuffer(str.length);\n  const arrBufUint8 = new Uint8Array(arrBuf);\n  for (let t = 0; t < str.length; t++) {\n    arrBufUint8[t] = str.charCodeAt(t);\n  }\n  return arrBuf;\n}\n\n// Convert a UInt8Array to a hex string.\nfunction uint8ArrToHex(uint8Arr) {\n  let hex = \"\";\n  for (const b of uint8Arr) {\n    hex += b.toString(16).padStart(2, \"0\");\n  }\n\n  // Also possible (but less readable) -\n  // let hex = \"\";\n  // uint8Arr.forEach(b => hex += b.toString(16).padStart(2, \"0\"));\n\n  return hex;\n}\n\n// Convert an ArrayBuffer to a hex string.\nfunction arrBufToHex(arrBuf) {\n  return uint8ArrToHex (new Uint8Array(arrBuf));\n}\n\n// Convert a hex string to a UInt8Array array.\nfunction hexToUint8Arr(hex) {\n  let bytes = [];\n  for (let t = 0; t < hex.length; t += 2) {\n    const byte = parseInt(hex.substr(t, 2), 16)\n    bytes.push (byte)\n  }\n  return new Uint8Array(bytes);\n}\n\n\n/*** Crypto ***/\n\nfunction getDerPublicKeyFromPem(pemText) {\n\n  // Based on https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#examples.\n\n  // Fetch Base64 encoded text between PEM markers.\n  const pemHeader = \"-----BEGIN PUBLIC KEY-----\";\n  const pemFooter = \"-----END PUBLIC KEY-----\";\n  const pemHeaderIndex = pemText.indexOf(pemHeader);\n  const pemFooterIndex = pemText.indexOf(pemFooter);\n  const pemBase64Text = pemText.substring(pemHeaderIndex + pemHeader.length, pemFooterIndex);\n\n  // Decode Base64 PEM text to DER.\n  const derBinaryStr = window.atob(pemBase64Text);\n\n  // Convert from a binary string to an ArrayBuffer.\n  const derPublicKey = binaryStrToArrayBuf(derBinaryStr);\n\n  return derPublicKey;\n}\n\n// Import an RSA public key (PEM format).\n// Key is imported with the specified hashing algorithm and as RSASSA-PKCS1-v1_5,\n// for signature verification only.\nfunction importRsaPublicKeyPem(pemText, hashAlgorithm) {\n\n  const derPublicKey = getDerPublicKeyFromPem(pemText);\n\n  return window.crypto.subtle.importKey(\n    \"spki\",  // SubjectPublicKeyInfo format\n    derPublicKey,\n    {  // RsaHashedImportParams algorithm\n      name: \"RSASSA-PKCS1-v1_5\",\n      hash: hashAlgorithm,\n    },\n    true,  // Extractable key\n    [\"verify\"],\n  );\n}\n\n// Import an ECDSA P-256 public key (PEM format).\n// Key is imported for signature verification only.\nfunction importEcdsaPublicKeyPem(pemText) {\n\n  const derPublicKey = getDerPublicKeyFromPem(pemText);\n\n  return window.crypto.subtle.importKey(\n    \"spki\",  // SubjectPublicKeyInfo format\n    derPublicKey,\n    { // EcKeyImportParams algorithm\n      name: \"ECDSA\",\n      namedCurve: \"P-256\",\n    },\n    true,  // Extractable key\n    [\"verify\"],\n  );\n}\n\n// Trim leading zeros (\"00\") in an hex string.\nfunction trimHexLeadingZeros(hexStr) {\n  while (hexStr.substr(0,2) == \"00\") {\n    hexStr = hexStr.substr(2);\n  }\n  return hexStr;\n};\n\n// Convert NIST P-256 signature in ASN.1 DER format to P1363 format.\n// Assumes the signature is of valid format.\n// DER format is used by OpenSSL.\n// P1363 format is used by WebCrypto.\nfunction signatureDerToP1363(derSignature) {\n\n  const derSignatureHex = arrBufToHex(derSignature);\n\n  /* \n   * ASN.1 DER format for signature -\n   *   Ecdsa-Sig-Value  ::=  SEQUENCE  {\n   *     r     INTEGER,\n   *     s     INTEGER  }\n   * (from https://datatracker.ietf.org/doc/html/rfc3278#section-8.2,\n   *  https://datatracker.ietf.org/doc/html/rfc3279#section-2.2.3)\n   * \n   * This is represented in hexa-decimal string as -\n   * \n   *   Offset          Value   Bytes   Description\n   *   ------          -----   -----   -------------------------------\n   *   0               0x30    2       SEQUENCE header\n   *   2               Size    2       Size of the SEQUENCE\n   *   4               0x02    2       INTEGER type\n   *   6               Size    2       Size of the INTEGER \"r\" = size_r\n   *   8               Bytes   size_r  Bytes of the INTEGER \"r\" (big endian)\n   *   8+(size_r*2)    0x02    2       INTEGER type\n   *   8+(size_r*2)+2  Size    2       Size of the INTEGER \"s\" = size_s\n   *   8+(size_r*2)+4  Bytes   size_s  Bytes of the INTEGER \"s\" (big endian)\n   */\n\n  if (parseInt(derSignatureHex.substr(0, 2), 16) != 0x30) {\n    throw \"Expected SEQUENCE at start of signature\";\n  }\n\n  if (parseInt(derSignatureHex.substr(4, 2), 16) != 0x02) {\n    throw \"Expected INTEGER as first value of sequence\";\n  }\n\n  // Parse size of \"r\".\n  const rSizeInHexChars = parseInt(derSignatureHex.substr(6, 2), 16) * 2;\n  // Get \"r\".\n  let r = derSignatureHex.substr(8, rSizeInHexChars);\n\n  if (parseInt(derSignatureHex.substr(8 + rSizeInHexChars, 2), 16) != 0x02) {\n    throw \"Expected INTEGER as second value of sequence\";\n  }\n\n  // Parse size of \"s\".\n  const sSizeInHexChars = parseInt(derSignatureHex.substr(8 + rSizeInHexChars + 2, 2), 16) * 2;\n  // Get \"s\".\n  let s = derSignatureHex.substr(8 + rSizeInHexChars + 4, sSizeInHexChars);\n\n  // Integers might be larger than 32 bytes in ASN.1 (because negative integers need to have a prefix of 0).\n  // Integers must be exactly 32 bytes in P1363 (padded by zeros).\n\n  // Trim all leading zeros from r and s, and pad to 32 bytes.\n  r = trimHexLeadingZeros(r).padStart(32*2, \"0\");\n  s = trimHexLeadingZeros(s).padStart(32*2, \"0\");\n\n  // Make sure the resulting strings are exactly 32 bytes long.\n  if ((r.length != 32*2) || (s.length != 32*2)) {\n    throw \"r or s are not of the expected size\";\n  }\n\n  // Concatenate r and s together - that's P1363 format.\n  return hexToUint8Arr(r + s);\n}\n\n\n/*** Main ***/\n\nvar qrCodeReader = null;\n\nvar scanVerifiedAudio = null;\nvar scanFailedAudio = null;\n\nconst RAMZOR_PUBLIC_KEYS_PEM = {\n  // RSA public key.\n  // From https://github.com/MohGovIL/Ramzor/blob/main/Verification/RSA/RamzorQRPubKey.der.\n  \"IL MOH\": \"-----BEGIN PUBLIC KEY-----\\n\" +\n            \"MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAw4MJrQWgRnYakBsoU/eV\\n\" +\n            \"RxpvDnrGvtidQtfU0o0OGKU+p3H16ufPusBzKLHQPGAoZB33lU8wvfP01xUJTvod\\n\" +\n            \"qoi6KEKXGXC+XreQ1YJDKhIglYfPxJOOcauWf/tmV+w0xph6O3L5/2JrhxEjIbdu\\n\" +\n            \"E8zP8FvZ+KxVFA9LOFQzX7zbbiDUBLCRtIBhwtLCPIiy960O+lVZkMPXg5BrBWjc\\n\" +\n            \"NBrDN62PgOxGXvP3iF0bOlz1+m63q9cFzdKqVfOyl8jZRr3GzYD8SVSXO9EbfYId\\n\" +\n            \"8DEP+HMmqd4StD2X6OMDc9UrBBHx3nGbRpi2D9QuHA/kq/QAjQqnrd+iuzdSwQi+\\n\" +\n            \"mQIDAQAB\\n\" +\n            \"-----END PUBLIC KEY-----\",\n\n  // ECDSA public key - used for most certificates.\n  // Used starting 3-Oct-2021.\n  // Derived from a few signatures using https://github.com/trianglee/greenpass-derive-public-key.\n  \"IL MOHEC\": \"-----BEGIN PUBLIC KEY-----\" +\n              \"MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEcw+UZUnryP4rqSw+a8xQw4wLHZkc\" +\n              \"u4MDjJP7QeBUEpDt8xh4i4RSIBEJrBkAukSSobRDkwMb0dSCsWwK0rfMgQ==\" +\n              \"-----END PUBLIC KEY-----\",\n             \n  // ECDSA public key - used for \"fast\" medical certificates.\n  // Derived from a few signatures using https://github.com/trianglee/greenpass-derive-public-key.\n  \"IL MOHEC_FAST\": \"-----BEGIN PUBLIC KEY-----\\n\" +\n                   \"MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEc/E5MuUnnyuhwv5LTFa8clYA/B7y\\n\" +\n                   \"S5tkSWjD4E8o0yxGDT+7095mIVDo65z8yeqVRie5BGDARZYzSfJpRF+TYA==\\n\" +\n                   \"-----END PUBLIC KEY-----\",\n\n  // Old, deprecated certificates -\n\n  // From https://github.com/MohGovIL/Ramzor/blob/main/Verification/ECDSA/RamzorQRPubKeyEC.der.\n  // Was used until 2-Oct-2021.\n  // \"IL MOHEC\": \"-----BEGIN PUBLIC KEY-----\\n\" +\n  //             \"MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEVD+aucpFLPK3HNnaZ/T/HeFGW84a\\n\" +\n  //             \"gCBnW0Je0CzzDjhWNdNgI0R74uMhqVAiAFOH2NPjPXgQmaNSpdwRhlGXTw==\\n\" +\n  //             \"-----END PUBLIC KEY-----\",\n}\n\nfunction onLoad() {\n\n  onVerifySignature();\n\n  const TIME_BETWEEN_SUCCESSFUL_DECODES_MILLIS = 2000;\n  const TIME_BETWEEN_DECODE_ATTEMPTS_MILLIS = 100;\n  qrCodeReader = new ZXing.BrowserQRCodeReader(TIME_BETWEEN_SUCCESSFUL_DECODES_MILLIS);\n  qrCodeReader.timeBetweenDecodingAttempts = TIME_BETWEEN_DECODE_ATTEMPTS_MILLIS;\n\n  scanVerifiedAudio = new Audio(\"sounds/success.wav\");\n  scanFailedAudio = new Audio(\"sounds/access-denied.wav\");\n}\n\n// Verify the QR code signature.\n// Returns a \"result\" object.\nasync function verifySignature(qrCodeText) {\n\n  var result = new Object();\n  result.text = null;\n  result.signedDataJson = null;\n\n  if (qrCodeText === \"\") {\n    return result;\n  }\n\n  try {\n    const separatorIndex = qrCodeText.indexOf(\"#\");\n    const signatureBase64 = qrCodeText.substr(0, separatorIndex);\n    const signedDataText = qrCodeText.substr(separatorIndex+1);\n\n    var signedDataJson = null;\n    try {\n      signedDataJson = JSON.parse(signedDataText);\n    } catch {\n      result.text = \"ERROR PARSING JSON!\";\n      return result;\n    }\n\n    // Decode signature from Base64.\n    var signature;\n    try {\n      const signatureBinStr = window.atob(signatureBase64);\n      signature = binaryStrToArrayBuf(signatureBinStr);\n    } catch {\n      result.text = \"ERROR DECODING SIGNATURE!\"\n      return result;\n    }\n\n    // Data is signed as UTF-8, encode it as UTF-8 before verification.\n    const encoder = new TextEncoder();\n    var signedData = encoder.encode(signedDataText);\n\n    var signatureType;\n    if (signedDataJson.et === 1) {\n      // \"RSA256-like\" signature type - apply SHA256 over the signed text explicitly\n      // (which is also done by the verify() function below, a second time).\n      signatureType = \"RSA\";\n      signedData = await sha256DigestPromise(signedData);\n    } else if (signedDataJson.et === 2) {\n      // \"RSA256\" signature type - standard verification used, no need to perform \n      // SHA256 explicitly.\n      signatureType = \"RSA\";\n    } else if (signedDataJson.et === 3) {\n      // \"ECDSA NIST P-256 with SHA256 hash\" signature type.\n      signatureType = \"ECDSA\";\n    } else {\n      // Unknown signature type.\n      result.text = \"UNKNOWN SIGNATURE TYPE!\";\n      return result;\n    }\n\n    const publicKeyName = signedDataJson[\"c\"];\n    if (!(publicKeyName in RAMZOR_PUBLIC_KEYS_PEM)) {\n      result.text = \"UNKNOWN PUBLIC KEY!\";\n      return result;\n    }\n    const publicKeyPem = RAMZOR_PUBLIC_KEYS_PEM[publicKeyName];\n\n    var signatureAlgorithm;\n    var publicKey;\n    if (signatureType == \"RSA\") {\n      signatureAlgorithm = \"RSASSA-PKCS1-v1_5\";\n      publicKey = await importRsaPublicKeyPem(publicKeyPem, \"sha-256\");\n    } else if (signatureType == \"ECDSA\") {\n      signatureAlgorithm = {\n        name: \"ECDSA\",\n        hash: \"SHA-256\",\n      };\n      publicKey = await importEcdsaPublicKeyPem(publicKeyPem);\n      // Signature needs to be converted from DER format to IEEE P1363 format, as DER\n      // is used by OpenSSL (and by Green Pass), and P1363 is used by WebCrypto.\n      signature = signatureDerToP1363(signature)\n    } else {\n      // Unknown signature type - shouldn't happen.\n      result.text = \"INTERNAL ERROR!\";\n      return result;\n    }\n\n    // Verify public key signature over signed data.\n    const signatureValid = \n      await window.crypto.subtle.verify(signatureAlgorithm, publicKey, signature, signedData);\n\n    if (signatureValid) {\n      result.text = \"Signature valid\"\n      result.signedDataJson = signedDataJson;\n    } else {\n      result.text = \"SIGNATURE NOT VALID!\"\n    }\n  } catch {\n    result.text = \"ERROR CHECKING SIGNATURE!\"\n  }\n\n  return result;\n}\n\nasync function onVerifySignature() {\n\n  const qrCodeText = document.getElementById(\"qrCodeText\").value;\n\n  var qrCodeTextStripped = qrCodeText.replaceAll(\"\\r\", \"\").replaceAll(\"\\n\", \"\")\n\n  var verifyResult = await verifySignature(qrCodeTextStripped);\n\n  document.getElementById(\"verifyResult\").value = verifyResult.text;\n\n  if (verifyResult.signedDataJson != null) {\n    // Signature is valid.\n    document.getElementById(\"verifyResult\").className = \"validSignature\";\n    document.getElementById(\"certType\").value = verifyResult.signedDataJson.ct;\n\n    switch (verifyResult.signedDataJson.ct) {\n      case 1:  // Vaccination certificate - without name\n        document.getElementById(\"idNumber\").value = verifyResult.signedDataJson.p[0].idl;\n        document.getElementById(\"name\").value = \"(unknown)\";\n        document.getElementById(\"expiration\").value = verifyResult.signedDataJson.p[0].e;\n        break;\n      case 4:   // \"Fast\" medical certificate\n        document.getElementById(\"idNumber\").value = verifyResult.signedDataJson.idl;\n        document.getElementById(\"name\").value = verifyResult.signedDataJson.g + \" \" + verifyResult.signedDataJson.f;\n        document.getElementById(\"expiration\").value = verifyResult.signedDataJson.e;\n        break;\n      case 2:   // Vaccination certificate - with name\n      case 3:   // Recovery certificate\n      case 6:   // Medical certificate\n      default:  // Hope this type is valid for all other unfamiliar certificate types.\n        document.getElementById(\"idNumber\").value = verifyResult.signedDataJson.idl;\n        document.getElementById(\"name\").value = verifyResult.signedDataJson.gl + \" \" + verifyResult.signedDataJson.fl;\n        document.getElementById(\"expiration\").value = verifyResult.signedDataJson.e;\n        break;\n    }\n\n    return true;\n\n  } else {\n    // Invalid signature.\n    document.getElementById(\"verifyResult\").className = \"invalidSignature\";\n    document.getElementById(\"certType\").value = \"\";\n    document.getElementById(\"idNumber\").value = \"\";\n    document.getElementById(\"name\").value = \"\";\n    document.getElementById(\"expiration\").value = \"\";\n\n    return false;\n  }\n}\n\nfunction displayCameraError(errorStr) {\n  document.getElementById(\"cameraError\").innerText = errorStr;\n}\n\nfunction onStartScanClick() {\n\n  displayCameraError(\"\");\n\n  // By default, use default camera (\"environment\" camera, if available).\n  let cameraId = null;\n\n  let cameraSelect = document.getElementById(\"cameraSelect\");\n  if (cameraSelect.length > 0) {\n    // If user explicitly selected another camera, use it instead.\n    // (-1 indicates \"default camera\").\n    if (cameraSelect.value != -1) {\n      cameraId = cameraSelect.value;\n    }\n  }\n\n  qrCodeReader.decodeFromInputVideoDeviceContinuously(cameraId, 'video', onDecode).catch(onStartScanError);\n}\n\nfunction onStopScanClick() {\n  qrCodeReader.reset();\n}\n\nfunction onSelectCameraButtonClick() {\n  qrCodeReader.listVideoInputDevices().then(devices => {\n    \n    if (devices.length === 0) {\n      displayCameraError(\"No cameras found!\");\n      return;\n    }\n\n    let cameraSelect = document.getElementById(\"cameraSelect\");\n\n    // Clear options list.\n    while (cameraSelect.length > 0) {                \n      cameraSelect.remove(0);\n    }      \n\n    // Add \"default camera\" option.\n    var option = document.createElement(\"option\");\n    option.value = -1;\n    option.text = \"(Default camera)\"\n    cameraSelect.add (option);\n\n    // Add all other listed cameras.\n    for (const device of devices) {\n      var option = document.createElement(\"option\");\n      option.value = device.deviceId;\n      option.text = device.label;\n      cameraSelect.add (option);\n    }\n\n    document.getElementById(\"cameraSelectionDiv\").style.display = \"block\";\n  });  \n}\n\nasync function onDecode(result, error) {\n  if (result !== null) {\n\n    document.getElementById(\"qrCodeText\").value = result;\n    const verified = await onVerifySignature();\n\n    if (verified) {\n      scanVerifiedAudio.play();\n    } else {\n      scanFailedAudio.play();\n    }\n  }\n\n  if (error !== null) {\n    if (error instanceof ZXing.NotFoundException) {\n      // QR code not found - do nothing.\n    } else if (error instanceof ZXing.ChecksumException) {\n      // QR code found but failed checksum validation - do nothing.\n    } else if (error instanceof ZXing.FormatException) {\n      // QR code found but wasn't properly formatted - do nothing.\n    } else {\n      displayCameraError (`Unexpected decode error (${error})`)\n    }\n  }\n}\n\nfunction onStartScanError(error) {\n  displayCameraError(\"Error starting camera!\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZ3JlZW5wYXNzLXZlcmlmeS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7O0FBR2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTzs7QUFFUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFTzs7QUFFUDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFTzs7QUFFUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOLHNEQUFzRCxNQUFNO0FBQzVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9HcmVlblBhc3NWZXJpZnkvLi9zcmMvZ3JlZW5wYXNzLXZlcmlmeS5qcz8xNjhiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBOaW1yb2QgWmltZXJtYW5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5cbi8qKiogU0hBMjU2ICoqKi9cblxuLy8gUGVyZm9ybSBTSEEyNTYgb3ZlciBhIGJ5dGUgYXJyYXkuXG4vLyBSZXR1cm5zIGEgYnl0ZSBhcnJheS5cbmFzeW5jIGZ1bmN0aW9uIHNoYTI1NkRpZ2VzdFByb21pc2UoYnl0ZUFycikge1xuICBjb25zdCBoYXNoID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5kaWdlc3QoXCJzaGEtMjU2XCIsIGJ5dGVBcnIpOyAgLy8gUmV0dXJucyBwcm9taXNlIG9mIEFycmF5QnVmZmVyLlxuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoaGFzaCk7XG59XG5cblxuLyoqKiBDb252ZXJzaW9uICoqKi9cblxuLy8gQ29udmVydCBhIGJpbmFyeSBzdHJpbmcgdG8gYW4gQXJyYXlCdWZmZXIuXG5mdW5jdGlvbiBiaW5hcnlTdHJUb0FycmF5QnVmKHN0cikge1xuICBjb25zdCBhcnJCdWYgPSBuZXcgQXJyYXlCdWZmZXIoc3RyLmxlbmd0aCk7XG4gIGNvbnN0IGFyckJ1ZlVpbnQ4ID0gbmV3IFVpbnQ4QXJyYXkoYXJyQnVmKTtcbiAgZm9yIChsZXQgdCA9IDA7IHQgPCBzdHIubGVuZ3RoOyB0KyspIHtcbiAgICBhcnJCdWZVaW50OFt0XSA9IHN0ci5jaGFyQ29kZUF0KHQpO1xuICB9XG4gIHJldHVybiBhcnJCdWY7XG59XG5cbi8vIENvbnZlcnQgYSBVSW50OEFycmF5IHRvIGEgaGV4IHN0cmluZy5cbmZ1bmN0aW9uIHVpbnQ4QXJyVG9IZXgodWludDhBcnIpIHtcbiAgbGV0IGhleCA9IFwiXCI7XG4gIGZvciAoY29uc3QgYiBvZiB1aW50OEFycikge1xuICAgIGhleCArPSBiLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIik7XG4gIH1cblxuICAvLyBBbHNvIHBvc3NpYmxlIChidXQgbGVzcyByZWFkYWJsZSkgLVxuICAvLyBsZXQgaGV4ID0gXCJcIjtcbiAgLy8gdWludDhBcnIuZm9yRWFjaChiID0+IGhleCArPSBiLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIikpO1xuXG4gIHJldHVybiBoZXg7XG59XG5cbi8vIENvbnZlcnQgYW4gQXJyYXlCdWZmZXIgdG8gYSBoZXggc3RyaW5nLlxuZnVuY3Rpb24gYXJyQnVmVG9IZXgoYXJyQnVmKSB7XG4gIHJldHVybiB1aW50OEFyclRvSGV4IChuZXcgVWludDhBcnJheShhcnJCdWYpKTtcbn1cblxuLy8gQ29udmVydCBhIGhleCBzdHJpbmcgdG8gYSBVSW50OEFycmF5IGFycmF5LlxuZnVuY3Rpb24gaGV4VG9VaW50OEFycihoZXgpIHtcbiAgbGV0IGJ5dGVzID0gW107XG4gIGZvciAobGV0IHQgPSAwOyB0IDwgaGV4Lmxlbmd0aDsgdCArPSAyKSB7XG4gICAgY29uc3QgYnl0ZSA9IHBhcnNlSW50KGhleC5zdWJzdHIodCwgMiksIDE2KVxuICAgIGJ5dGVzLnB1c2ggKGJ5dGUpXG4gIH1cbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ5dGVzKTtcbn1cblxuXG4vKioqIENyeXB0byAqKiovXG5cbmZ1bmN0aW9uIGdldERlclB1YmxpY0tleUZyb21QZW0ocGVtVGV4dCkge1xuXG4gIC8vIEJhc2VkIG9uIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TdWJ0bGVDcnlwdG8vaW1wb3J0S2V5I2V4YW1wbGVzLlxuXG4gIC8vIEZldGNoIEJhc2U2NCBlbmNvZGVkIHRleHQgYmV0d2VlbiBQRU0gbWFya2Vycy5cbiAgY29uc3QgcGVtSGVhZGVyID0gXCItLS0tLUJFR0lOIFBVQkxJQyBLRVktLS0tLVwiO1xuICBjb25zdCBwZW1Gb290ZXIgPSBcIi0tLS0tRU5EIFBVQkxJQyBLRVktLS0tLVwiO1xuICBjb25zdCBwZW1IZWFkZXJJbmRleCA9IHBlbVRleHQuaW5kZXhPZihwZW1IZWFkZXIpO1xuICBjb25zdCBwZW1Gb290ZXJJbmRleCA9IHBlbVRleHQuaW5kZXhPZihwZW1Gb290ZXIpO1xuICBjb25zdCBwZW1CYXNlNjRUZXh0ID0gcGVtVGV4dC5zdWJzdHJpbmcocGVtSGVhZGVySW5kZXggKyBwZW1IZWFkZXIubGVuZ3RoLCBwZW1Gb290ZXJJbmRleCk7XG5cbiAgLy8gRGVjb2RlIEJhc2U2NCBQRU0gdGV4dCB0byBERVIuXG4gIGNvbnN0IGRlckJpbmFyeVN0ciA9IHdpbmRvdy5hdG9iKHBlbUJhc2U2NFRleHQpO1xuXG4gIC8vIENvbnZlcnQgZnJvbSBhIGJpbmFyeSBzdHJpbmcgdG8gYW4gQXJyYXlCdWZmZXIuXG4gIGNvbnN0IGRlclB1YmxpY0tleSA9IGJpbmFyeVN0clRvQXJyYXlCdWYoZGVyQmluYXJ5U3RyKTtcblxuICByZXR1cm4gZGVyUHVibGljS2V5O1xufVxuXG4vLyBJbXBvcnQgYW4gUlNBIHB1YmxpYyBrZXkgKFBFTSBmb3JtYXQpLlxuLy8gS2V5IGlzIGltcG9ydGVkIHdpdGggdGhlIHNwZWNpZmllZCBoYXNoaW5nIGFsZ29yaXRobSBhbmQgYXMgUlNBU1NBLVBLQ1MxLXYxXzUsXG4vLyBmb3Igc2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBvbmx5LlxuZnVuY3Rpb24gaW1wb3J0UnNhUHVibGljS2V5UGVtKHBlbVRleHQsIGhhc2hBbGdvcml0aG0pIHtcblxuICBjb25zdCBkZXJQdWJsaWNLZXkgPSBnZXREZXJQdWJsaWNLZXlGcm9tUGVtKHBlbVRleHQpO1xuXG4gIHJldHVybiB3aW5kb3cuY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoXG4gICAgXCJzcGtpXCIsICAvLyBTdWJqZWN0UHVibGljS2V5SW5mbyBmb3JtYXRcbiAgICBkZXJQdWJsaWNLZXksXG4gICAgeyAgLy8gUnNhSGFzaGVkSW1wb3J0UGFyYW1zIGFsZ29yaXRobVxuICAgICAgbmFtZTogXCJSU0FTU0EtUEtDUzEtdjFfNVwiLFxuICAgICAgaGFzaDogaGFzaEFsZ29yaXRobSxcbiAgICB9LFxuICAgIHRydWUsICAvLyBFeHRyYWN0YWJsZSBrZXlcbiAgICBbXCJ2ZXJpZnlcIl0sXG4gICk7XG59XG5cbi8vIEltcG9ydCBhbiBFQ0RTQSBQLTI1NiBwdWJsaWMga2V5IChQRU0gZm9ybWF0KS5cbi8vIEtleSBpcyBpbXBvcnRlZCBmb3Igc2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBvbmx5LlxuZnVuY3Rpb24gaW1wb3J0RWNkc2FQdWJsaWNLZXlQZW0ocGVtVGV4dCkge1xuXG4gIGNvbnN0IGRlclB1YmxpY0tleSA9IGdldERlclB1YmxpY0tleUZyb21QZW0ocGVtVGV4dCk7XG5cbiAgcmV0dXJuIHdpbmRvdy5jcnlwdG8uc3VidGxlLmltcG9ydEtleShcbiAgICBcInNwa2lcIiwgIC8vIFN1YmplY3RQdWJsaWNLZXlJbmZvIGZvcm1hdFxuICAgIGRlclB1YmxpY0tleSxcbiAgICB7IC8vIEVjS2V5SW1wb3J0UGFyYW1zIGFsZ29yaXRobVxuICAgICAgbmFtZTogXCJFQ0RTQVwiLFxuICAgICAgbmFtZWRDdXJ2ZTogXCJQLTI1NlwiLFxuICAgIH0sXG4gICAgdHJ1ZSwgIC8vIEV4dHJhY3RhYmxlIGtleVxuICAgIFtcInZlcmlmeVwiXSxcbiAgKTtcbn1cblxuLy8gVHJpbSBsZWFkaW5nIHplcm9zIChcIjAwXCIpIGluIGFuIGhleCBzdHJpbmcuXG5mdW5jdGlvbiB0cmltSGV4TGVhZGluZ1plcm9zKGhleFN0cikge1xuICB3aGlsZSAoaGV4U3RyLnN1YnN0cigwLDIpID09IFwiMDBcIikge1xuICAgIGhleFN0ciA9IGhleFN0ci5zdWJzdHIoMik7XG4gIH1cbiAgcmV0dXJuIGhleFN0cjtcbn07XG5cbi8vIENvbnZlcnQgTklTVCBQLTI1NiBzaWduYXR1cmUgaW4gQVNOLjEgREVSIGZvcm1hdCB0byBQMTM2MyBmb3JtYXQuXG4vLyBBc3N1bWVzIHRoZSBzaWduYXR1cmUgaXMgb2YgdmFsaWQgZm9ybWF0LlxuLy8gREVSIGZvcm1hdCBpcyB1c2VkIGJ5IE9wZW5TU0wuXG4vLyBQMTM2MyBmb3JtYXQgaXMgdXNlZCBieSBXZWJDcnlwdG8uXG5mdW5jdGlvbiBzaWduYXR1cmVEZXJUb1AxMzYzKGRlclNpZ25hdHVyZSkge1xuXG4gIGNvbnN0IGRlclNpZ25hdHVyZUhleCA9IGFyckJ1ZlRvSGV4KGRlclNpZ25hdHVyZSk7XG5cbiAgLyogXG4gICAqIEFTTi4xIERFUiBmb3JtYXQgZm9yIHNpZ25hdHVyZSAtXG4gICAqICAgRWNkc2EtU2lnLVZhbHVlICA6Oj0gIFNFUVVFTkNFICB7XG4gICAqICAgICByICAgICBJTlRFR0VSLFxuICAgKiAgICAgcyAgICAgSU5URUdFUiAgfVxuICAgKiAoZnJvbSBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzMyNzgjc2VjdGlvbi04LjIsXG4gICAqICBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzMyNzkjc2VjdGlvbi0yLjIuMylcbiAgICogXG4gICAqIFRoaXMgaXMgcmVwcmVzZW50ZWQgaW4gaGV4YS1kZWNpbWFsIHN0cmluZyBhcyAtXG4gICAqIFxuICAgKiAgIE9mZnNldCAgICAgICAgICBWYWx1ZSAgIEJ5dGVzICAgRGVzY3JpcHRpb25cbiAgICogICAtLS0tLS0gICAgICAgICAgLS0tLS0gICAtLS0tLSAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogICAwICAgICAgICAgICAgICAgMHgzMCAgICAyICAgICAgIFNFUVVFTkNFIGhlYWRlclxuICAgKiAgIDIgICAgICAgICAgICAgICBTaXplICAgIDIgICAgICAgU2l6ZSBvZiB0aGUgU0VRVUVOQ0VcbiAgICogICA0ICAgICAgICAgICAgICAgMHgwMiAgICAyICAgICAgIElOVEVHRVIgdHlwZVxuICAgKiAgIDYgICAgICAgICAgICAgICBTaXplICAgIDIgICAgICAgU2l6ZSBvZiB0aGUgSU5URUdFUiBcInJcIiA9IHNpemVfclxuICAgKiAgIDggICAgICAgICAgICAgICBCeXRlcyAgIHNpemVfciAgQnl0ZXMgb2YgdGhlIElOVEVHRVIgXCJyXCIgKGJpZyBlbmRpYW4pXG4gICAqICAgOCsoc2l6ZV9yKjIpICAgIDB4MDIgICAgMiAgICAgICBJTlRFR0VSIHR5cGVcbiAgICogICA4KyhzaXplX3IqMikrMiAgU2l6ZSAgICAyICAgICAgIFNpemUgb2YgdGhlIElOVEVHRVIgXCJzXCIgPSBzaXplX3NcbiAgICogICA4KyhzaXplX3IqMikrNCAgQnl0ZXMgICBzaXplX3MgIEJ5dGVzIG9mIHRoZSBJTlRFR0VSIFwic1wiIChiaWcgZW5kaWFuKVxuICAgKi9cblxuICBpZiAocGFyc2VJbnQoZGVyU2lnbmF0dXJlSGV4LnN1YnN0cigwLCAyKSwgMTYpICE9IDB4MzApIHtcbiAgICB0aHJvdyBcIkV4cGVjdGVkIFNFUVVFTkNFIGF0IHN0YXJ0IG9mIHNpZ25hdHVyZVwiO1xuICB9XG5cbiAgaWYgKHBhcnNlSW50KGRlclNpZ25hdHVyZUhleC5zdWJzdHIoNCwgMiksIDE2KSAhPSAweDAyKSB7XG4gICAgdGhyb3cgXCJFeHBlY3RlZCBJTlRFR0VSIGFzIGZpcnN0IHZhbHVlIG9mIHNlcXVlbmNlXCI7XG4gIH1cblxuICAvLyBQYXJzZSBzaXplIG9mIFwiclwiLlxuICBjb25zdCByU2l6ZUluSGV4Q2hhcnMgPSBwYXJzZUludChkZXJTaWduYXR1cmVIZXguc3Vic3RyKDYsIDIpLCAxNikgKiAyO1xuICAvLyBHZXQgXCJyXCIuXG4gIGxldCByID0gZGVyU2lnbmF0dXJlSGV4LnN1YnN0cig4LCByU2l6ZUluSGV4Q2hhcnMpO1xuXG4gIGlmIChwYXJzZUludChkZXJTaWduYXR1cmVIZXguc3Vic3RyKDggKyByU2l6ZUluSGV4Q2hhcnMsIDIpLCAxNikgIT0gMHgwMikge1xuICAgIHRocm93IFwiRXhwZWN0ZWQgSU5URUdFUiBhcyBzZWNvbmQgdmFsdWUgb2Ygc2VxdWVuY2VcIjtcbiAgfVxuXG4gIC8vIFBhcnNlIHNpemUgb2YgXCJzXCIuXG4gIGNvbnN0IHNTaXplSW5IZXhDaGFycyA9IHBhcnNlSW50KGRlclNpZ25hdHVyZUhleC5zdWJzdHIoOCArIHJTaXplSW5IZXhDaGFycyArIDIsIDIpLCAxNikgKiAyO1xuICAvLyBHZXQgXCJzXCIuXG4gIGxldCBzID0gZGVyU2lnbmF0dXJlSGV4LnN1YnN0cig4ICsgclNpemVJbkhleENoYXJzICsgNCwgc1NpemVJbkhleENoYXJzKTtcblxuICAvLyBJbnRlZ2VycyBtaWdodCBiZSBsYXJnZXIgdGhhbiAzMiBieXRlcyBpbiBBU04uMSAoYmVjYXVzZSBuZWdhdGl2ZSBpbnRlZ2VycyBuZWVkIHRvIGhhdmUgYSBwcmVmaXggb2YgMCkuXG4gIC8vIEludGVnZXJzIG11c3QgYmUgZXhhY3RseSAzMiBieXRlcyBpbiBQMTM2MyAocGFkZGVkIGJ5IHplcm9zKS5cblxuICAvLyBUcmltIGFsbCBsZWFkaW5nIHplcm9zIGZyb20gciBhbmQgcywgYW5kIHBhZCB0byAzMiBieXRlcy5cbiAgciA9IHRyaW1IZXhMZWFkaW5nWmVyb3MocikucGFkU3RhcnQoMzIqMiwgXCIwXCIpO1xuICBzID0gdHJpbUhleExlYWRpbmdaZXJvcyhzKS5wYWRTdGFydCgzMioyLCBcIjBcIik7XG5cbiAgLy8gTWFrZSBzdXJlIHRoZSByZXN1bHRpbmcgc3RyaW5ncyBhcmUgZXhhY3RseSAzMiBieXRlcyBsb25nLlxuICBpZiAoKHIubGVuZ3RoICE9IDMyKjIpIHx8IChzLmxlbmd0aCAhPSAzMioyKSkge1xuICAgIHRocm93IFwiciBvciBzIGFyZSBub3Qgb2YgdGhlIGV4cGVjdGVkIHNpemVcIjtcbiAgfVxuXG4gIC8vIENvbmNhdGVuYXRlIHIgYW5kIHMgdG9nZXRoZXIgLSB0aGF0J3MgUDEzNjMgZm9ybWF0LlxuICByZXR1cm4gaGV4VG9VaW50OEFycihyICsgcyk7XG59XG5cblxuLyoqKiBNYWluICoqKi9cblxudmFyIHFyQ29kZVJlYWRlciA9IG51bGw7XG5cbnZhciBzY2FuVmVyaWZpZWRBdWRpbyA9IG51bGw7XG52YXIgc2NhbkZhaWxlZEF1ZGlvID0gbnVsbDtcblxuY29uc3QgUkFNWk9SX1BVQkxJQ19LRVlTX1BFTSA9IHtcbiAgLy8gUlNBIHB1YmxpYyBrZXkuXG4gIC8vIEZyb20gaHR0cHM6Ly9naXRodWIuY29tL01vaEdvdklML1JhbXpvci9ibG9iL21haW4vVmVyaWZpY2F0aW9uL1JTQS9SYW16b3JRUlB1YktleS5kZXIuXG4gIFwiSUwgTU9IXCI6IFwiLS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS1cXG5cIiArXG4gICAgICAgICAgICBcIk1JSUJJakFOQmdrcWhraUc5dzBCQVFFRkFBT0NBUThBTUlJQkNnS0NBUUVBdzRNSnJRV2dSbllha0Jzb1UvZVZcXG5cIiArXG4gICAgICAgICAgICBcIlJ4cHZEbnJHdnRpZFF0ZlUwbzBPR0tVK3AzSDE2dWZQdXNCektMSFFQR0FvWkIzM2xVOHd2ZlAwMXhVSlR2b2RcXG5cIiArXG4gICAgICAgICAgICBcInFvaTZLRUtYR1hDK1hyZVExWUpES2hJZ2xZZlB4Sk9PY2F1V2YvdG1WK3cweHBoNk8zTDUvMkpyaHhFakliZHVcXG5cIiArXG4gICAgICAgICAgICBcIkU4elA4RnZaK0t4VkZBOUxPRlF6WDd6YmJpRFVCTENSdElCaHd0TENQSWl5OTYwTytsVlprTVBYZzVCckJXamNcXG5cIiArXG4gICAgICAgICAgICBcIk5CckRONjJQZ094R1h2UDNpRjBiT2x6MSttNjNxOWNGemRLcVZmT3lsOGpaUnIzR3pZRDhTVlNYTzlFYmZZSWRcXG5cIiArXG4gICAgICAgICAgICBcIjhERVArSE1tcWQ0U3REMlg2T01EYzlVckJCSHgzbkdiUnBpMkQ5UXVIQS9rcS9RQWpRcW5yZCtpdXpkU3dRaStcXG5cIiArXG4gICAgICAgICAgICBcIm1RSURBUUFCXFxuXCIgK1xuICAgICAgICAgICAgXCItLS0tLUVORCBQVUJMSUMgS0VZLS0tLS1cIixcblxuICAvLyBFQ0RTQSBwdWJsaWMga2V5IC0gdXNlZCBmb3IgbW9zdCBjZXJ0aWZpY2F0ZXMuXG4gIC8vIFVzZWQgc3RhcnRpbmcgMy1PY3QtMjAyMS5cbiAgLy8gRGVyaXZlZCBmcm9tIGEgZmV3IHNpZ25hdHVyZXMgdXNpbmcgaHR0cHM6Ly9naXRodWIuY29tL3RyaWFuZ2xlZS9ncmVlbnBhc3MtZGVyaXZlLXB1YmxpYy1rZXkuXG4gIFwiSUwgTU9IRUNcIjogXCItLS0tLUJFR0lOIFBVQkxJQyBLRVktLS0tLVwiICtcbiAgICAgICAgICAgICAgXCJNRmt3RXdZSEtvWkl6ajBDQVFZSUtvWkl6ajBEQVFjRFFnQUVjdytVWlVucnlQNHJxU3crYTh4UXc0d0xIWmtjXCIgK1xuICAgICAgICAgICAgICBcInU0TURqSlA3UWVCVUVwRHQ4eGg0aTRSU0lCRUpyQmtBdWtTU29iUkRrd01iMGRTQ3NXd0swcmZNZ1E9PVwiICtcbiAgICAgICAgICAgICAgXCItLS0tLUVORCBQVUJMSUMgS0VZLS0tLS1cIixcbiAgICAgICAgICAgICBcbiAgLy8gRUNEU0EgcHVibGljIGtleSAtIHVzZWQgZm9yIFwiZmFzdFwiIG1lZGljYWwgY2VydGlmaWNhdGVzLlxuICAvLyBEZXJpdmVkIGZyb20gYSBmZXcgc2lnbmF0dXJlcyB1c2luZyBodHRwczovL2dpdGh1Yi5jb20vdHJpYW5nbGVlL2dyZWVucGFzcy1kZXJpdmUtcHVibGljLWtleS5cbiAgXCJJTCBNT0hFQ19GQVNUXCI6IFwiLS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS1cXG5cIiArXG4gICAgICAgICAgICAgICAgICAgXCJNRmt3RXdZSEtvWkl6ajBDQVFZSUtvWkl6ajBEQVFjRFFnQUVjL0U1TXVVbm55dWh3djVMVEZhOGNsWUEvQjd5XFxuXCIgK1xuICAgICAgICAgICAgICAgICAgIFwiUzV0a1NXakQ0RThvMHl4R0RUKzcwOTVtSVZEbzY1ejh5ZXFWUmllNUJHREFSWll6U2ZKcFJGK1RZQT09XFxuXCIgK1xuICAgICAgICAgICAgICAgICAgIFwiLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tXCIsXG5cbiAgLy8gT2xkLCBkZXByZWNhdGVkIGNlcnRpZmljYXRlcyAtXG5cbiAgLy8gRnJvbSBodHRwczovL2dpdGh1Yi5jb20vTW9oR292SUwvUmFtem9yL2Jsb2IvbWFpbi9WZXJpZmljYXRpb24vRUNEU0EvUmFtem9yUVJQdWJLZXlFQy5kZXIuXG4gIC8vIFdhcyB1c2VkIHVudGlsIDItT2N0LTIwMjEuXG4gIC8vIFwiSUwgTU9IRUNcIjogXCItLS0tLUJFR0lOIFBVQkxJQyBLRVktLS0tLVxcblwiICtcbiAgLy8gICAgICAgICAgICAgXCJNRmt3RXdZSEtvWkl6ajBDQVFZSUtvWkl6ajBEQVFjRFFnQUVWRCthdWNwRkxQSzNITm5hWi9UL0hlRkdXODRhXFxuXCIgK1xuICAvLyAgICAgICAgICAgICBcImdDQm5XMEplMEN6ekRqaFdOZE5nSTBSNzR1TWhxVkFpQUZPSDJOUGpQWGdRbWFOU3Bkd1JobEdYVHc9PVxcblwiICtcbiAgLy8gICAgICAgICAgICAgXCItLS0tLUVORCBQVUJMSUMgS0VZLS0tLS1cIixcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9uTG9hZCgpIHtcblxuICBvblZlcmlmeVNpZ25hdHVyZSgpO1xuXG4gIGNvbnN0IFRJTUVfQkVUV0VFTl9TVUNDRVNTRlVMX0RFQ09ERVNfTUlMTElTID0gMjAwMDtcbiAgY29uc3QgVElNRV9CRVRXRUVOX0RFQ09ERV9BVFRFTVBUU19NSUxMSVMgPSAxMDA7XG4gIHFyQ29kZVJlYWRlciA9IG5ldyBaWGluZy5Ccm93c2VyUVJDb2RlUmVhZGVyKFRJTUVfQkVUV0VFTl9TVUNDRVNTRlVMX0RFQ09ERVNfTUlMTElTKTtcbiAgcXJDb2RlUmVhZGVyLnRpbWVCZXR3ZWVuRGVjb2RpbmdBdHRlbXB0cyA9IFRJTUVfQkVUV0VFTl9ERUNPREVfQVRURU1QVFNfTUlMTElTO1xuXG4gIHNjYW5WZXJpZmllZEF1ZGlvID0gbmV3IEF1ZGlvKFwic291bmRzL3N1Y2Nlc3Mud2F2XCIpO1xuICBzY2FuRmFpbGVkQXVkaW8gPSBuZXcgQXVkaW8oXCJzb3VuZHMvYWNjZXNzLWRlbmllZC53YXZcIik7XG59XG5cbi8vIFZlcmlmeSB0aGUgUVIgY29kZSBzaWduYXR1cmUuXG4vLyBSZXR1cm5zIGEgXCJyZXN1bHRcIiBvYmplY3QuXG5hc3luYyBmdW5jdGlvbiB2ZXJpZnlTaWduYXR1cmUocXJDb2RlVGV4dCkge1xuXG4gIHZhciByZXN1bHQgPSBuZXcgT2JqZWN0KCk7XG4gIHJlc3VsdC50ZXh0ID0gbnVsbDtcbiAgcmVzdWx0LnNpZ25lZERhdGFKc29uID0gbnVsbDtcblxuICBpZiAocXJDb2RlVGV4dCA9PT0gXCJcIikge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IHNlcGFyYXRvckluZGV4ID0gcXJDb2RlVGV4dC5pbmRleE9mKFwiI1wiKTtcbiAgICBjb25zdCBzaWduYXR1cmVCYXNlNjQgPSBxckNvZGVUZXh0LnN1YnN0cigwLCBzZXBhcmF0b3JJbmRleCk7XG4gICAgY29uc3Qgc2lnbmVkRGF0YVRleHQgPSBxckNvZGVUZXh0LnN1YnN0cihzZXBhcmF0b3JJbmRleCsxKTtcblxuICAgIHZhciBzaWduZWREYXRhSnNvbiA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgIHNpZ25lZERhdGFKc29uID0gSlNPTi5wYXJzZShzaWduZWREYXRhVGV4dCk7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXN1bHQudGV4dCA9IFwiRVJST1IgUEFSU0lORyBKU09OIVwiO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBEZWNvZGUgc2lnbmF0dXJlIGZyb20gQmFzZTY0LlxuICAgIHZhciBzaWduYXR1cmU7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZUJpblN0ciA9IHdpbmRvdy5hdG9iKHNpZ25hdHVyZUJhc2U2NCk7XG4gICAgICBzaWduYXR1cmUgPSBiaW5hcnlTdHJUb0FycmF5QnVmKHNpZ25hdHVyZUJpblN0cik7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXN1bHQudGV4dCA9IFwiRVJST1IgREVDT0RJTkcgU0lHTkFUVVJFIVwiXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIERhdGEgaXMgc2lnbmVkIGFzIFVURi04LCBlbmNvZGUgaXQgYXMgVVRGLTggYmVmb3JlIHZlcmlmaWNhdGlvbi5cbiAgICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgdmFyIHNpZ25lZERhdGEgPSBlbmNvZGVyLmVuY29kZShzaWduZWREYXRhVGV4dCk7XG5cbiAgICB2YXIgc2lnbmF0dXJlVHlwZTtcbiAgICBpZiAoc2lnbmVkRGF0YUpzb24uZXQgPT09IDEpIHtcbiAgICAgIC8vIFwiUlNBMjU2LWxpa2VcIiBzaWduYXR1cmUgdHlwZSAtIGFwcGx5IFNIQTI1NiBvdmVyIHRoZSBzaWduZWQgdGV4dCBleHBsaWNpdGx5XG4gICAgICAvLyAod2hpY2ggaXMgYWxzbyBkb25lIGJ5IHRoZSB2ZXJpZnkoKSBmdW5jdGlvbiBiZWxvdywgYSBzZWNvbmQgdGltZSkuXG4gICAgICBzaWduYXR1cmVUeXBlID0gXCJSU0FcIjtcbiAgICAgIHNpZ25lZERhdGEgPSBhd2FpdCBzaGEyNTZEaWdlc3RQcm9taXNlKHNpZ25lZERhdGEpO1xuICAgIH0gZWxzZSBpZiAoc2lnbmVkRGF0YUpzb24uZXQgPT09IDIpIHtcbiAgICAgIC8vIFwiUlNBMjU2XCIgc2lnbmF0dXJlIHR5cGUgLSBzdGFuZGFyZCB2ZXJpZmljYXRpb24gdXNlZCwgbm8gbmVlZCB0byBwZXJmb3JtIFxuICAgICAgLy8gU0hBMjU2IGV4cGxpY2l0bHkuXG4gICAgICBzaWduYXR1cmVUeXBlID0gXCJSU0FcIjtcbiAgICB9IGVsc2UgaWYgKHNpZ25lZERhdGFKc29uLmV0ID09PSAzKSB7XG4gICAgICAvLyBcIkVDRFNBIE5JU1QgUC0yNTYgd2l0aCBTSEEyNTYgaGFzaFwiIHNpZ25hdHVyZSB0eXBlLlxuICAgICAgc2lnbmF0dXJlVHlwZSA9IFwiRUNEU0FcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVW5rbm93biBzaWduYXR1cmUgdHlwZS5cbiAgICAgIHJlc3VsdC50ZXh0ID0gXCJVTktOT1dOIFNJR05BVFVSRSBUWVBFIVwiO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBjb25zdCBwdWJsaWNLZXlOYW1lID0gc2lnbmVkRGF0YUpzb25bXCJjXCJdO1xuICAgIGlmICghKHB1YmxpY0tleU5hbWUgaW4gUkFNWk9SX1BVQkxJQ19LRVlTX1BFTSkpIHtcbiAgICAgIHJlc3VsdC50ZXh0ID0gXCJVTktOT1dOIFBVQkxJQyBLRVkhXCI7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBjb25zdCBwdWJsaWNLZXlQZW0gPSBSQU1aT1JfUFVCTElDX0tFWVNfUEVNW3B1YmxpY0tleU5hbWVdO1xuXG4gICAgdmFyIHNpZ25hdHVyZUFsZ29yaXRobTtcbiAgICB2YXIgcHVibGljS2V5O1xuICAgIGlmIChzaWduYXR1cmVUeXBlID09IFwiUlNBXCIpIHtcbiAgICAgIHNpZ25hdHVyZUFsZ29yaXRobSA9IFwiUlNBU1NBLVBLQ1MxLXYxXzVcIjtcbiAgICAgIHB1YmxpY0tleSA9IGF3YWl0IGltcG9ydFJzYVB1YmxpY0tleVBlbShwdWJsaWNLZXlQZW0sIFwic2hhLTI1NlwiKTtcbiAgICB9IGVsc2UgaWYgKHNpZ25hdHVyZVR5cGUgPT0gXCJFQ0RTQVwiKSB7XG4gICAgICBzaWduYXR1cmVBbGdvcml0aG0gPSB7XG4gICAgICAgIG5hbWU6IFwiRUNEU0FcIixcbiAgICAgICAgaGFzaDogXCJTSEEtMjU2XCIsXG4gICAgICB9O1xuICAgICAgcHVibGljS2V5ID0gYXdhaXQgaW1wb3J0RWNkc2FQdWJsaWNLZXlQZW0ocHVibGljS2V5UGVtKTtcbiAgICAgIC8vIFNpZ25hdHVyZSBuZWVkcyB0byBiZSBjb252ZXJ0ZWQgZnJvbSBERVIgZm9ybWF0IHRvIElFRUUgUDEzNjMgZm9ybWF0LCBhcyBERVJcbiAgICAgIC8vIGlzIHVzZWQgYnkgT3BlblNTTCAoYW5kIGJ5IEdyZWVuIFBhc3MpLCBhbmQgUDEzNjMgaXMgdXNlZCBieSBXZWJDcnlwdG8uXG4gICAgICBzaWduYXR1cmUgPSBzaWduYXR1cmVEZXJUb1AxMzYzKHNpZ25hdHVyZSlcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVW5rbm93biBzaWduYXR1cmUgdHlwZSAtIHNob3VsZG4ndCBoYXBwZW4uXG4gICAgICByZXN1bHQudGV4dCA9IFwiSU5URVJOQUwgRVJST1IhXCI7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIFZlcmlmeSBwdWJsaWMga2V5IHNpZ25hdHVyZSBvdmVyIHNpZ25lZCBkYXRhLlxuICAgIGNvbnN0IHNpZ25hdHVyZVZhbGlkID0gXG4gICAgICBhd2FpdCB3aW5kb3cuY3J5cHRvLnN1YnRsZS52ZXJpZnkoc2lnbmF0dXJlQWxnb3JpdGhtLCBwdWJsaWNLZXksIHNpZ25hdHVyZSwgc2lnbmVkRGF0YSk7XG5cbiAgICBpZiAoc2lnbmF0dXJlVmFsaWQpIHtcbiAgICAgIHJlc3VsdC50ZXh0ID0gXCJTaWduYXR1cmUgdmFsaWRcIlxuICAgICAgcmVzdWx0LnNpZ25lZERhdGFKc29uID0gc2lnbmVkRGF0YUpzb247XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC50ZXh0ID0gXCJTSUdOQVRVUkUgTk9UIFZBTElEIVwiXG4gICAgfVxuICB9IGNhdGNoIHtcbiAgICByZXN1bHQudGV4dCA9IFwiRVJST1IgQ0hFQ0tJTkcgU0lHTkFUVVJFIVwiXG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gb25WZXJpZnlTaWduYXR1cmUoKSB7XG5cbiAgY29uc3QgcXJDb2RlVGV4dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicXJDb2RlVGV4dFwiKS52YWx1ZTtcblxuICB2YXIgcXJDb2RlVGV4dFN0cmlwcGVkID0gcXJDb2RlVGV4dC5yZXBsYWNlQWxsKFwiXFxyXCIsIFwiXCIpLnJlcGxhY2VBbGwoXCJcXG5cIiwgXCJcIilcblxuICB2YXIgdmVyaWZ5UmVzdWx0ID0gYXdhaXQgdmVyaWZ5U2lnbmF0dXJlKHFyQ29kZVRleHRTdHJpcHBlZCk7XG5cbiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ2ZXJpZnlSZXN1bHRcIikudmFsdWUgPSB2ZXJpZnlSZXN1bHQudGV4dDtcblxuICBpZiAodmVyaWZ5UmVzdWx0LnNpZ25lZERhdGFKc29uICE9IG51bGwpIHtcbiAgICAvLyBTaWduYXR1cmUgaXMgdmFsaWQuXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ2ZXJpZnlSZXN1bHRcIikuY2xhc3NOYW1lID0gXCJ2YWxpZFNpZ25hdHVyZVwiO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY2VydFR5cGVcIikudmFsdWUgPSB2ZXJpZnlSZXN1bHQuc2lnbmVkRGF0YUpzb24uY3Q7XG5cbiAgICBzd2l0Y2ggKHZlcmlmeVJlc3VsdC5zaWduZWREYXRhSnNvbi5jdCkge1xuICAgICAgY2FzZSAxOiAgLy8gVmFjY2luYXRpb24gY2VydGlmaWNhdGUgLSB3aXRob3V0IG5hbWVcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpZE51bWJlclwiKS52YWx1ZSA9IHZlcmlmeVJlc3VsdC5zaWduZWREYXRhSnNvbi5wWzBdLmlkbDtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJuYW1lXCIpLnZhbHVlID0gXCIodW5rbm93bilcIjtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJleHBpcmF0aW9uXCIpLnZhbHVlID0gdmVyaWZ5UmVzdWx0LnNpZ25lZERhdGFKc29uLnBbMF0uZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDQ6ICAgLy8gXCJGYXN0XCIgbWVkaWNhbCBjZXJ0aWZpY2F0ZVxuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImlkTnVtYmVyXCIpLnZhbHVlID0gdmVyaWZ5UmVzdWx0LnNpZ25lZERhdGFKc29uLmlkbDtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJuYW1lXCIpLnZhbHVlID0gdmVyaWZ5UmVzdWx0LnNpZ25lZERhdGFKc29uLmcgKyBcIiBcIiArIHZlcmlmeVJlc3VsdC5zaWduZWREYXRhSnNvbi5mO1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImV4cGlyYXRpb25cIikudmFsdWUgPSB2ZXJpZnlSZXN1bHQuc2lnbmVkRGF0YUpzb24uZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6ICAgLy8gVmFjY2luYXRpb24gY2VydGlmaWNhdGUgLSB3aXRoIG5hbWVcbiAgICAgIGNhc2UgMzogICAvLyBSZWNvdmVyeSBjZXJ0aWZpY2F0ZVxuICAgICAgY2FzZSA2OiAgIC8vIE1lZGljYWwgY2VydGlmaWNhdGVcbiAgICAgIGRlZmF1bHQ6ICAvLyBIb3BlIHRoaXMgdHlwZSBpcyB2YWxpZCBmb3IgYWxsIG90aGVyIHVuZmFtaWxpYXIgY2VydGlmaWNhdGUgdHlwZXMuXG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaWROdW1iZXJcIikudmFsdWUgPSB2ZXJpZnlSZXN1bHQuc2lnbmVkRGF0YUpzb24uaWRsO1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm5hbWVcIikudmFsdWUgPSB2ZXJpZnlSZXN1bHQuc2lnbmVkRGF0YUpzb24uZ2wgKyBcIiBcIiArIHZlcmlmeVJlc3VsdC5zaWduZWREYXRhSnNvbi5mbDtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJleHBpcmF0aW9uXCIpLnZhbHVlID0gdmVyaWZ5UmVzdWx0LnNpZ25lZERhdGFKc29uLmU7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuXG4gIH0gZWxzZSB7XG4gICAgLy8gSW52YWxpZCBzaWduYXR1cmUuXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ2ZXJpZnlSZXN1bHRcIikuY2xhc3NOYW1lID0gXCJpbnZhbGlkU2lnbmF0dXJlXCI7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjZXJ0VHlwZVwiKS52YWx1ZSA9IFwiXCI7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpZE51bWJlclwiKS52YWx1ZSA9IFwiXCI7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJuYW1lXCIpLnZhbHVlID0gXCJcIjtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImV4cGlyYXRpb25cIikudmFsdWUgPSBcIlwiO1xuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRpc3BsYXlDYW1lcmFFcnJvcihlcnJvclN0cikge1xuICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNhbWVyYUVycm9yXCIpLmlubmVyVGV4dCA9IGVycm9yU3RyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb25TdGFydFNjYW5DbGljaygpIHtcblxuICBkaXNwbGF5Q2FtZXJhRXJyb3IoXCJcIik7XG5cbiAgLy8gQnkgZGVmYXVsdCwgdXNlIGRlZmF1bHQgY2FtZXJhIChcImVudmlyb25tZW50XCIgY2FtZXJhLCBpZiBhdmFpbGFibGUpLlxuICBsZXQgY2FtZXJhSWQgPSBudWxsO1xuXG4gIGxldCBjYW1lcmFTZWxlY3QgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNhbWVyYVNlbGVjdFwiKTtcbiAgaWYgKGNhbWVyYVNlbGVjdC5sZW5ndGggPiAwKSB7XG4gICAgLy8gSWYgdXNlciBleHBsaWNpdGx5IHNlbGVjdGVkIGFub3RoZXIgY2FtZXJhLCB1c2UgaXQgaW5zdGVhZC5cbiAgICAvLyAoLTEgaW5kaWNhdGVzIFwiZGVmYXVsdCBjYW1lcmFcIikuXG4gICAgaWYgKGNhbWVyYVNlbGVjdC52YWx1ZSAhPSAtMSkge1xuICAgICAgY2FtZXJhSWQgPSBjYW1lcmFTZWxlY3QudmFsdWU7XG4gICAgfVxuICB9XG5cbiAgcXJDb2RlUmVhZGVyLmRlY29kZUZyb21JbnB1dFZpZGVvRGV2aWNlQ29udGludW91c2x5KGNhbWVyYUlkLCAndmlkZW8nLCBvbkRlY29kZSkuY2F0Y2gob25TdGFydFNjYW5FcnJvcik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvblN0b3BTY2FuQ2xpY2soKSB7XG4gIHFyQ29kZVJlYWRlci5yZXNldCgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb25TZWxlY3RDYW1lcmFCdXR0b25DbGljaygpIHtcbiAgcXJDb2RlUmVhZGVyLmxpc3RWaWRlb0lucHV0RGV2aWNlcygpLnRoZW4oZGV2aWNlcyA9PiB7XG4gICAgXG4gICAgaWYgKGRldmljZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBkaXNwbGF5Q2FtZXJhRXJyb3IoXCJObyBjYW1lcmFzIGZvdW5kIVwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgY2FtZXJhU2VsZWN0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjYW1lcmFTZWxlY3RcIik7XG5cbiAgICAvLyBDbGVhciBvcHRpb25zIGxpc3QuXG4gICAgd2hpbGUgKGNhbWVyYVNlbGVjdC5sZW5ndGggPiAwKSB7ICAgICAgICAgICAgICAgIFxuICAgICAgY2FtZXJhU2VsZWN0LnJlbW92ZSgwKTtcbiAgICB9ICAgICAgXG5cbiAgICAvLyBBZGQgXCJkZWZhdWx0IGNhbWVyYVwiIG9wdGlvbi5cbiAgICB2YXIgb3B0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcbiAgICBvcHRpb24udmFsdWUgPSAtMTtcbiAgICBvcHRpb24udGV4dCA9IFwiKERlZmF1bHQgY2FtZXJhKVwiXG4gICAgY2FtZXJhU2VsZWN0LmFkZCAob3B0aW9uKTtcblxuICAgIC8vIEFkZCBhbGwgb3RoZXIgbGlzdGVkIGNhbWVyYXMuXG4gICAgZm9yIChjb25zdCBkZXZpY2Ugb2YgZGV2aWNlcykge1xuICAgICAgdmFyIG9wdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XG4gICAgICBvcHRpb24udmFsdWUgPSBkZXZpY2UuZGV2aWNlSWQ7XG4gICAgICBvcHRpb24udGV4dCA9IGRldmljZS5sYWJlbDtcbiAgICAgIGNhbWVyYVNlbGVjdC5hZGQgKG9wdGlvbik7XG4gICAgfVxuXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjYW1lcmFTZWxlY3Rpb25EaXZcIikuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgfSk7ICBcbn1cblxuYXN5bmMgZnVuY3Rpb24gb25EZWNvZGUocmVzdWx0LCBlcnJvcikge1xuICBpZiAocmVzdWx0ICE9PSBudWxsKSB7XG5cbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInFyQ29kZVRleHRcIikudmFsdWUgPSByZXN1bHQ7XG4gICAgY29uc3QgdmVyaWZpZWQgPSBhd2FpdCBvblZlcmlmeVNpZ25hdHVyZSgpO1xuXG4gICAgaWYgKHZlcmlmaWVkKSB7XG4gICAgICBzY2FuVmVyaWZpZWRBdWRpby5wbGF5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjYW5GYWlsZWRBdWRpby5wbGF5KCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVycm9yICE9PSBudWxsKSB7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgWlhpbmcuTm90Rm91bmRFeGNlcHRpb24pIHtcbiAgICAgIC8vIFFSIGNvZGUgbm90IGZvdW5kIC0gZG8gbm90aGluZy5cbiAgICB9IGVsc2UgaWYgKGVycm9yIGluc3RhbmNlb2YgWlhpbmcuQ2hlY2tzdW1FeGNlcHRpb24pIHtcbiAgICAgIC8vIFFSIGNvZGUgZm91bmQgYnV0IGZhaWxlZCBjaGVja3N1bSB2YWxpZGF0aW9uIC0gZG8gbm90aGluZy5cbiAgICB9IGVsc2UgaWYgKGVycm9yIGluc3RhbmNlb2YgWlhpbmcuRm9ybWF0RXhjZXB0aW9uKSB7XG4gICAgICAvLyBRUiBjb2RlIGZvdW5kIGJ1dCB3YXNuJ3QgcHJvcGVybHkgZm9ybWF0dGVkIC0gZG8gbm90aGluZy5cbiAgICB9IGVsc2Uge1xuICAgICAgZGlzcGxheUNhbWVyYUVycm9yIChgVW5leHBlY3RlZCBkZWNvZGUgZXJyb3IgKCR7ZXJyb3J9KWApXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG9uU3RhcnRTY2FuRXJyb3IoZXJyb3IpIHtcbiAgZGlzcGxheUNhbWVyYUVycm9yKFwiRXJyb3Igc3RhcnRpbmcgY2FtZXJhIVwiKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/greenpass-verify.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/greenpass-verify.js"](0, __webpack_exports__, __webpack_require__);
/******/ 	GreenPassVerify = __webpack_exports__;
/******/ 	
/******/ })()
;